{"blogs":[{"title":" Angular framework","content":"Angular is a TypeScript-based, free and open-source web application framework led by the Angular Team at Google and by a community of individuals and corporations. Angular is a complete rewrite from the same team that built AngularJS. \n\nWikipedia","id":1685354370218},{"title":"fsdfs","author":"fsdf","content":"sdfsf\r\nfdgf\r\nhfht","id":1685429780015},{"title":"Nodejs ","content":"Generated jwts will include an iat (issued at) claim by default unless noTimestamp is specified. If iat is inserted in the payload, it will be used instead of the real timestamp for calculating other things like exp given a timespan in options.expiresIn.\r\n\r\nSynchronous Sign with default (HMAC SHA256)\r\n\r\nvar jwt = require('jsonwebtoken');\r\nvar token = jwt.sign({ foo: 'bar' }, 'shhhhh');\r\nSynchronous Sign with RSA SHA256\r\n\r\n// sign with RSA SHA256\r\nvar privateKey = fs.readFileSync('private.key');\r\nvar token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' });\r\nSign asynchronously\r\n\r\njwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {\r\n  console.log(token);\r\n});\r\nBackdate a jwt 30 seconds\r\n\r\nvar older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');\r\nToken Expiration (exp claim)\r\nThe standard for JWT defines an exp claim for expiration. The expiration is represented as a NumericDate:\r\n\r\nA JSON numeric value representing the number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time, ignoring leap seconds. This is equivalent to the IEEE Std 1003.1, 2013 Edition [POSIX.1] definition \"Seconds Since the Epoch\", in which each day is accounted for by exactly 86400 seconds, other than that non-integer values can be represented. See RFC 3339 [RFC3339] for details regarding date/times in general and UTC in particular.\r\n\r\nThis means that the exp field should contain the number of seconds since the epoch.\r\n\r\nSigning a token with 1 hour of expiration:\r\n\r\njwt.sign({\r\n  exp: Math.floor(Date.now() / 1000) + (60 * 60),\r\n  data: 'foobar'\r\n}, 'secret');\r\nAnother way to generate a token like this with this library is:\r\n\r\njwt.sign({\r\n  data: 'foobar'\r\n}, 'secret', { expiresIn: 60 * 60 });\r\n\r\n//or even better:\r\n\r\njwt.sign({\r\n  data: 'foobar'\r\n}, 'secret', { expiresIn: '1h' });\r\njwt.verify(token, secretOrPublicKey, [options, callback])\r\n(Asynchronous) If a callback is supplied, function acts asynchronously. The callback is called with the decoded payload if the signature is valid and optional expiration, audience, or issuer are valid. If not, it will be called with the error.\r\n\r\n(Synchronous) If a callback is not supplied, function acts synchronously. Returns the payload decoded if the signature is valid and optional expiration, audience, or issuer are valid. If not, it will throw the error.\r\n\r\nWarning: When the token comes from an untrusted source (e.g. user input or external requests), the returned decoded payload should be treated like any other user input; please make sure to sanitize and only work with properties that are expected\r\n\r\ntoken is the JsonWebToken string\r\n\r\nsecretOrPublicKey is a string (utf-8 encoded), buffer, or KeyObject containing either the secret for HMAC algorithms, or the PEM encoded public key for RSA and ECDSA. If jwt.verify is called asynchronous, secretOrPublicKey can be a function that should fetch the secret or public key. See below for a detailed example\r\n\r\nAs mentioned in this comment, there are other libraries that expect base64 encoded secrets (random bytes encoded using base64), if that is your case you can pass Buffer.from(secret, 'base64'), by doing this the secret will be decoded using base64 and the token verification will use the original random bytes.\r\n\r\noptions\r\n\r\nalgorithms: List of strings with the names of the allowed algorithms. For instance, [\"HS256\", \"HS384\"].\r\nIf not specified a defaults will be used based on the type of key provided\r\n\r\nsecret - ['HS256', 'HS384', 'HS512']\r\nrsa - ['RS256', 'RS384', 'RS512']\r\nec - ['ES256', 'ES384', 'ES512']\r\ndefault - ['RS256', 'RS384', 'RS512']\r\naudience: if you want to check audience (aud), provide a value here. The audience can be checked against a string, a regular expression or a list of strings and/or regular expressions.\r\nEg: \"urn:foo\", /urn:f[o]{2}/, [/urn:f[o]{2}/, \"urn:bar\"]\r\n\r\ncomplete: return an object with the decoded { payload, header, signature } instead of only the usual content of the payload.\r\nissuer (optional): string or array of strings of valid values for the iss field.\r\njwtid (optional): if you want to check JWT ID (jti), provide a string value here.\r\nignoreExpiration: if true do not validate the expiration of the token.\r\nignoreNotBefore...\r\nsubject: if you want to check subject (sub), provide a value here\r\nclockTolerance: number of seconds to tolerate when checking the nbf and exp claims, to deal with small clock differences among different servers\r\nmaxAge: the maximum allowed age for tokens to still be valid. It is expressed in seconds or a string describing a time span vercel/ms.\r\nEg: 1000, \"2 days\", \"10h\", \"7d\". A numeric value is interpreted as a seconds count. If you use a string be sure you provide the time units (days, hours, etc), otherwise milliseconds unit is used by default (\"120\" is equal to \"120ms\").\r\n\r\nclockTimestamp: the time in seconds that should be used as the current time for all necessary comparisons.\r\nnonce: if you want to check nonce claim, provide a string value here. It is used on Open ID for the ID Tokens. (Open ID implementation notes)\r\nallowInvalidAsymmetricKeyTypes: if true, allows asymmetric keys which do not match the specified algorithm. This option is intended only for backwards compatability and should be avoided.\r\n// verify a token symmetric - synchronous\r\nvar decoded = jwt.verify(token, 'shhhhh');\r\nconsole.log(decoded.foo) // bar\r\n\r\n// verify a token symmetric\r\njwt.verify(token, 'shhhhh', function(err, decoded) {\r\n  console.log(decoded.foo) // bar\r\n});\r\n\r\n// invalid token - synchronous\r\ntry {\r\n  var decoded = jwt.verify(token, 'wrong-secret');\r\n} catch(err) {\r\n  // err\r\n}\r\n\r\n// invalid token\r\njwt.verify(token, 'wrong-secret', function(err, decoded) {\r\n  // err\r\n  // decoded undefined\r\n});\r\n\r\n// verify a token asymmetric\r\nvar cert = fs.readFileSync('public.pem');  // get public key\r\njwt.verify(token, cert, function(err, decoded) {\r\n  console.log(decoded.foo) // bar\r\n});\r\n\r\n// verify audience\r\nvar cert = fs.readFileSync('public.pem');  // get public key\r\njwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {\r\n  // if audience mismatch, err == invalid audience\r\n});\r\n\r\n// verify issuer\r\nvar cert = fs.readFileSync('public.pem');  // get public key\r\njwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {\r\n  // if issuer mismatch, err == invalid issuer\r\n});\r\n\r\n// verify jwt id\r\nvar cert = fs.readFileSync('public.pem');  // get public key\r\njwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {\r\n  // if jwt id mismatch, err == invalid jwt id\r\n});\r\n\r\n// verify subject\r\nvar cert = fs.readFileSync('public.pem');  // get public key\r\njwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {\r\n  // if subject mismatch, err == invalid subject\r\n});\r\n\r\n// alg mismatch\r\nvar cert = fs.readFileSync('public.pem'); // get public key\r\njwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {\r\n  // if token alg != RS256,  err == invalid signature\r\n});\r\n\r\n// Verify using getKey callback\r\n// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.\r\nvar jwksClient = require('jwks-rsa');\r\nvar client = jwksClient({\r\n  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'\r\n});\r\nfunction getKey(header, callback){\r\n  client.getSigningKey(header.kid, function(err, key) {\r\n    var signingKey = key.publicKey || key.rsaPublicKey;\r\n    callback(null, signingKey);\r\n  });\r\n}\r\n\r\njwt.verify(token, getKey, options, function(err, decoded) {\r\n  console.log(decoded.foo) // bar\r\n});\r\nNeed to peek into a JWT without verifying it? (Click to expand)\r\nErrors & Codes\r\nPossible thrown errors during verification. Error is the first argument of the verification callback.\r\n\r\nTokenExpiredError\r\nThrown error if the token is expired.\r\n\r\nError object:\r\n\r\nname: 'TokenExpiredError'\r\nmessage: 'jwt expired'\r\nexpiredAt: [ExpDate]\r\njwt.verify(token, 'shhhhh', function(err, decoded) {\r\n  if (err) {\r\n    /*\r\n      err = {\r\n        name: 'TokenExpiredError',\r\n        message: 'jwt expired',\r\n        expiredAt: 1408621000\r\n      }\r\n    */\r\n  }\r\n});\r\nJsonWebTokenError\r\nError object:\r\n\r\nname: 'JsonWebTokenError'\r\nmessage:\r\n'invalid token' - the header or payload could not be parsed\r\n'jwt malformed' - the token does not have three components (delimited by a .)\r\n'jwt signature is required'\r\n'invalid signature'\r\n'jwt audience invalid. expected: [OPTIONS AUDIENCE]'\r\n'jwt issuer invalid. expected: [OPTIONS ISSUER]'\r\n'jwt id invalid. expected: [OPTIONS JWT ID]'\r\n'jwt subject invalid. expected: [OPTIONS SUBJECT]'\r\njwt.verify(token, 'shhhhh', function(err, decoded) {\r\n  if (err) {\r\n    /*\r\n      err = {\r\n        name: 'JsonWebTokenError',\r\n        message: 'jwt malformed'\r\n      }\r\n    */\r\n  }\r\n});\r\nNotBeforeError\r\nThrown if current time is before the nbf claim.\r\n\r\nError object:\r\n\r\nname: 'NotBeforeError'\r\nmessage: 'jwt not active'\r\ndate: 2018-10-04T16:10:44.000Z\r\njwt.verify(token, 'shhhhh', function(err, decoded) {\r\n  if (err) {\r\n    /*\r\n      err = {\r\n        name: 'NotBeforeError',\r\n        message: 'jwt not active',\r\n        date: 2018-10-04T16:10:44.000Z\r\n      }\r\n    */\r\n  }\r\n});\r\nAlgorithms supported\r\nArray of supported algorithms. The following algorithms are currently supported.\r\n\r\nalg Parameter Value\tDigital Signature or MAC Algorithm\r\nHS256\tHMAC using SHA-256 hash algorithm\r\nHS384\tHMAC using SHA-384 hash algorithm\r\nHS512\tHMAC using SHA-512 hash algorithm\r\nRS256\tRSASSA-PKCS1-v1_5 using SHA-256 hash algorithm\r\nRS384\tRSASSA-PKCS1-v1_5 using SHA-384 hash algorithm\r\nRS512\tRSASSA-PKCS1-v1_5 using SHA-512 hash algorithm\r\nPS256\tRSASSA-PSS using SHA-256 hash algorithm (only node ^6.12.0 OR >=8.0.0)\r\nPS384\tRSASSA-PSS using SHA-384 hash algorithm (only node ^6.12.0 OR >=8.0.0)\r\nPS512\tRSASSA-PSS using SHA-512 hash algorithm (only node ^6.12.0 OR >=8.0.0)\r\nES256\tECDSA using P-256 curve and SHA-256 hash algorithm\r\nES384\tECDSA using P-384 curve and SHA-384 hash algorithm\r\nES512\tECDSA using P-521 curve and SHA-512 hash algorithm\r\nnone\tNo digital signature or MAC value included\r\nRefreshing JWTs\r\nFirst of all, we recommend you to think carefully if auto-refreshing a JWT will not introduce any vulnerability in your system.\r\n\r\nWe are not comfortable including this as part of the library, however, you can take a look at this example to show how this could be accomplished. Apart from that example there are an issue and a pull request to get more knowledge about this topic.\r\n\r\nTODO\r\nX.509 certificate chain is not checked\r\nIssue Reporting\r\nIf you have found a bug or if you have a feature request, please report them at this repository issues section. Please do not report security vulnerabilities on the public GitHub issue tracker. The Responsible Disclosure Program details the procedure for disclosing security issues.\r\n\r\nAuthor\r\nAuth0\r\n\r\nLicense\r\nThis project is licensed under the MIT license. See the LICENSE file for more info.\r\n\r\nWant a few flashcards to help the article stick better? ðŸ§ \r\n\r\nGenerate Flashcards\r\n\r\nWisdolia\r\n\r\nKeywords\r\njwt\r\nInstall\r\nnpm i jsonwebtoken\r\n\r\nRepository\r\ngithub.com/auth0/node-jsonwebtoken\r\n\r\nHomepage\r\ngithub.com/auth0/node-jsonwebtoken#readme\r\n\r\nWeekly Downloads\r\n11,705,630\r\n\r\nVersion\r\n9.0.0\r\n\r\nLicense\r\nMIT\r\n\r\nUnpacked Size\r\n43.1 kB\r\n\r\nTotal Files\r\n15\r\n\r\nIssues\r\n99\r\n\r\nPull Requests\r\n38\r\n\r\nLast publish\r\n5 months ago\r\n\r\nCollaborators\r\njulien.wollscheid\r\njake.lacey\r\nlbalmaceda\r\nziluvatar\r\nwoloski\r\njfromaniello\r\niaco\r\ndschenkelman\r\ncharlesrea\r\ndavid.renaud.okta\r\nmadhuri.rm23\r\nedgarchirivella-okta\r\nTry on RunKit\r\nReport malware","id":1685959419353},{"title":"JavaScript","content":"Generated jwts will include an iat (issued at) \n\n// verify audience\nvar cert = fs.readFileSync(&#39;public.pem&#39;);  // get public key\njwt.verify(token, cert, { audience: &#39;urn:foo&#39; }, function(err, decoded) {\n  // if audience mismatch, err == invalid audience\n});\n\n// verify issuer\nvar cert = fs.readFileSync(&#39;public.pem&#39;);  // get public key\njwt.verify(token, cert, { audience: &#39;urn:foo&#39;, issuer: &#39;urn:issuer&#39; }, function(err, decoded) {\n  // if issuer mismatch, err == invalid issuer\n","id":1685959492084,"author":"sahil"}]}